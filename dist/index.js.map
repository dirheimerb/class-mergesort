{"version":3,"sources":["../src/index.ts"],"sourcesContent":["export type ValidationObject =\n  | string\n  | number\n  | Record<string, any>\n  | null\n  | undefined;\n/**\n * Toggle a class name based on a condition.\n *\n * @param className - The class name to toggle.\n * @param condition - The condition determining whether the class should be added.\n * @returns The class name if the condition is true, otherwise an empty string.\n */\nexport function toggleClass(className: string, condition: boolean): string {\n  return condition ? className : '';\n}\n/**\n * Add a prefix to each class name in the list.\n *\n * @param prefix - The prefix to add.\n * @param classNames - List of class names.\n * @returns A single string with each class name prefixed.\n */\nexport function prefixClass(prefix: string, ...classNames: string[]): string {\n  return classNames.map((name) => `${prefix}${name}`).join(' ');\n}\n/**\n * Add a suffix to each class name in the list.\n *\n * @param suffix - The suffix to add.\n * @param classNames - List of class names.\n * @returns A single string with each class name suffixed.\n */\nexport function suffixClass(suffix: string, ...classNames: string[]): string {\n  return classNames.map((name) => `${name}${suffix}`).join(' ');\n}\n/**\n * Filter class names based on a custom condition function.\n *\n * @param condition - The condition function.\n * @param classNames - List of class names.\n * @returns A single string containing class names that meet the condition.\n */\nexport function filterClass(\n  condition: (className: string) => boolean,\n  ...classNames: string[]\n): string {\n  return classNames.filter(condition).join(' ');\n}\n/**\n * Merges multiple class name strings or arrays, eliminating duplicates.\n *\n * @param args - Class name strings or arrays of class names to be merged.\n * @returns A single string containing the merged and unique class names.\n */\nexport function mergeClass(...args: (string | string[])[]): string {\n  const classSet = new Set<string>();\n  args.forEach((arg) => {\n    if (typeof arg === 'string') {\n      arg.split(' ').forEach((className) => classSet.add(className));\n    } else if (Array.isArray(arg)) {\n      arg.forEach((className) => classSet.add(className));\n    }\n  });\n  return Array.from(classSet).join(' ');\n}\n/**\n * Function to convert a variety of types into a valid class name string.\n *\n * @param mix - The input which can be a string, number, array, or object.\n * @returns A string after concatenation and validation.\n */\nfunction toVal(mix: ValidationObject): string {\n  let k: string | number;\n  let y: string;\n  let str: string = '';\n  // Handle strings and numbers directly\n  if (typeof mix === 'string' || typeof mix === 'number') {\n    str += mix;\n  } else if (typeof mix === 'object' && mix !== null) {\n    // Ensure it's not null as typeof null is 'object'\n    // If it's an array, loop through its elements\n    if (Array.isArray(mix)) {\n      for (k = 0; k < mix.length; k++) {\n        if (mix[k]) {\n          y = toVal(mix[k]);\n          if (y) {\n            str && (str += ' ');\n            str += y;\n          }\n        }\n      }\n    } else {\n      // If it's an object, loop through its keys\n      for (k in mix) {\n        if (Object.prototype.hasOwnProperty.call(mix, k) && mix[k]) {\n          str && (str += ' ');\n          str += k;\n        }\n      }\n    }\n  }\n  return str;\n}\n/**\n * Function to concatenate multiple class names into a single string.\n *\n * @param args - Spread of various types including string, number, array, and object.\n * @returns A concatenated string of class names.\n */\nexport function classNameX(...args: ValidationObject[]): string {\n  let i: number = 0;\n  let mix: ValidationObject;\n  let x: string;\n  let str: string = '';\n  // Loop through each argument\n  while (i < args.length) {\n    mix = args[i++];\n    if (mix) {\n      x = toVal(mix);\n      if (x) {\n        str && (str += ' ');\n        str += x;\n      }\n    }\n  }\n  return str;\n}\n"],"mappings":"AAaO,SAASA,EAAYC,EAAmBC,EAA4B,CACzE,OAAOA,EAAYD,EAAY,EACjC,CAQO,SAASE,EAAYC,KAAmBC,EAA8B,CAC3E,OAAOA,EAAW,IAAKC,GAAS,GAAGF,CAAM,GAAGE,CAAI,EAAE,EAAE,KAAK,GAAG,CAC9D,CAQO,SAASC,EAAYC,KAAmBH,EAA8B,CAC3E,OAAOA,EAAW,IAAKC,GAAS,GAAGA,CAAI,GAAGE,CAAM,EAAE,EAAE,KAAK,GAAG,CAC9D,CAQO,SAASC,EACdP,KACGG,EACK,CACR,OAAOA,EAAW,OAAOH,CAAS,EAAE,KAAK,GAAG,CAC9C,CAOO,SAASQ,KAAcC,EAAqC,CACjE,IAAMC,EAAW,IAAI,IACrB,OAAAD,EAAK,QAASE,GAAQ,CAChB,OAAOA,GAAQ,SACjBA,EAAI,MAAM,GAAG,EAAE,QAASZ,GAAcW,EAAS,IAAIX,CAAS,CAAC,EACpD,MAAM,QAAQY,CAAG,GAC1BA,EAAI,QAASZ,GAAcW,EAAS,IAAIX,CAAS,CAAC,CAEtD,CAAC,EACM,MAAM,KAAKW,CAAQ,EAAE,KAAK,GAAG,CACtC,CAOA,SAASE,EAAMC,EAA+B,CAC5C,IAAIC,EACAC,EACAC,EAAc,GAElB,GAAI,OAAOH,GAAQ,UAAY,OAAOA,GAAQ,SAC5CG,GAAOH,UACE,OAAOA,GAAQ,UAAYA,IAAQ,KAG5C,GAAI,MAAM,QAAQA,CAAG,EACnB,IAAKC,EAAI,EAAGA,EAAID,EAAI,OAAQC,IACtBD,EAAIC,CAAC,IACPC,EAAIH,EAAMC,EAAIC,CAAC,CAAC,EACZC,IACFC,IAAQA,GAAO,KACfA,GAAOD,QAMb,KAAKD,KAAKD,EACJ,OAAO,UAAU,eAAe,KAAKA,EAAKC,CAAC,GAAKD,EAAIC,CAAC,IACvDE,IAAQA,GAAO,KACfA,GAAOF,GAKf,OAAOE,CACT,CAOO,SAASC,KAAcR,EAAkC,CAC9D,IAAIS,EAAY,EACZL,EACAM,EACAH,EAAc,GAElB,KAAOE,EAAIT,EAAK,QACdI,EAAMJ,EAAKS,GAAG,EACVL,IACFM,EAAIP,EAAMC,CAAG,EACTM,IACFH,IAAQA,GAAO,KACfA,GAAOG,IAIb,OAAOH,CACT","names":["toggleClass","className","condition","prefixClass","prefix","classNames","name","suffixClass","suffix","filterClass","mergeClass","args","classSet","arg","toVal","mix","k","y","str","classNameX","i","x"]}